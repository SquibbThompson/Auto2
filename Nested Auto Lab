import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import PillowWriter

# convert binary string to matrix
def string_to_bin_matrix(bin_string):
    bin_string = bin_string.replace(" ", "")
    bin_string = bin_string.replace("]","")
    bin_string = bin_string.replace("[", "")
    return [[int(bit) for bit in line] for line in bin_string.split('\n') if line]

# Insert Bin Array
binary_string = """
#Enter 2D array here (example)
00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000
00111111111111111111111111111111111111111111111111111100
00111111111111111111111111111111111111111111111111111100
00110000000000000000000000000000000000000000000000001100
00110111111111111111111111111111111111111111111111101100
00110111111111111111111111111111111111111111111111101100
00110110000000000000000000000000000000000000000001101100
00110110000000000000000000000000000000000000000001101100
00110110011111111111111111111111111111111111111001101100
00110110011111111111111111111111111111111111111001101100
00110110011000000000000000000000000000000000011001101100
00110110011011111111111111111111111111111111011001101100
00110110011011111111111111111111111111111111011001101100
00110110011011000000000000000000000000000011011001101100
00110110011011000000000000000000000000000011011001101100
00110110011011001111111111111111111111110011011001101100
00110110011011001111111111111111111111110011011001101100
00110110011011001100000000000000000000110011011001101100
00110110011011001101111111111111111110110011011001101100
00110110011011001101111111111111111110110011011001101100
00110110011011001101100000000000000110110011011001101100
00110110011011001101100000000000000110110011011001101100
00110110011011001101100000000000000110110011011001101100
00110110011011001101100000011011000110110011011001101100
00110110011011001101100000110110000110110011011001101100
00110110011011001101100001101100000110110011011001101100
00110110011011001101100011011000000110110011011001101100
00110110011011001101100010110001000110110011011001101100
00110110011011001101100001100011000110110011011001101100
00110110011011001101100011000110000110110011011001101100
00110110011011001101100010001101000110110011011001101100
00110110011011001101100000000000000110110011011001101100
00110110011011001101100000000000000110110011011001101100
00110110011011001101100000000000000110110011011001101100
00110110011011001101111111111111111110110011011001101100
00110110011011001101111111111111111110110011011001101100
00110110011011001100000000000000000000110011011001101100
00110110011011001111111111111111111111110011011001101100
00110110011011001111111111111111111111110011011001101100
00110110011011000000000000000000000000000011011001101100
00110110011011000000000000000000000000000011011001101100
00110110011011111111111111111111111111111111011001101100
00110110011011111111111111111111111111111111011001101100
00110110011000000000000000000000000000000000011001101100
00110110011111111111111111111111111111111111111001101100
00110110011111111111111111111111111111111111111001101100
00110110000000000000000000000000000000000000000001101100
00110110000000000000000000000000000000000000000001101100
00110111111111111111111111111111111111111111111111101100
00110111111111111111111111111111111111111111111111101100
00110000000000000000000000000000000000000000000000001100
00111111111111111111111111111111111111111111111111111100
00111111111111111111111111111111111111111111111111111100
00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000


""".strip()


# generate initial state
initial_state = np.array(string_to_bin_matrix(binary_string))

# define the function that checks and updates the matrix
def update_matrix(matrix):
    updated_matrix = matrix.copy()
    height, width = matrix.shape

    # define the criteria for active neighbors
    active_neighbors_criteria = {1,2,3}

    # loop over each cell in the matrix
    for i in range(height):
        for j in range(width):
            # check the number of 'Active' cells surrounding the current cell
            Active = 0
            for x in range(i - 1, i + 2):
                for y in range(j - 1, j + 2):
                    if (x, y) != (i, j) and x >= 0 and y >= 0 and x < height and y < width:
                        if matrix[x, y] == 1:
                            Active += 1

            # invert the cell color if an 'Inactive' {user input criteria}
            if matrix[i, j] == 0 and Active in active_neighbors_criteria:
                updated_matrix[i, j] = 1
            elif matrix[i, j] == 1 and Active in active_neighbors_criteria:
                # turn two diagonal 'Active' cells to 'Inactive'
                if i > 0 and j > 0 and matrix[i - 1, j - 1] == 1:
                    updated_matrix[i - 1, j - 1] = 0
                if i > 0 and j < width - 1 and matrix[i - 1, j + 1] == 1:
                    updated_matrix[i - 1, j + 1] = 0
                if i < height - 1 and j > 0 and matrix[i + 1, j - 1] == 1:
                    updated_matrix[i + 1, j - 1] = 0
                if i < height - 1 and j < width - 1 and matrix[i + 1, j + 1] == 1:
                    updated_matrix[i + 1, j + 1] = 0

    return updated_matrix

# animate cellular automata evolution
def animate(i):
    global initial_state

    initial_state = update_matrix(initial_state)
    plt.imshow(initial_state, cmap='binary')

fig, ax = plt.subplots()
global ani
ani = animation.FuncAnimation(fig, animate, frames=28, interval=24)



# Save the animation as a GIF
#ani.save('Barbershop Pole Psuedo_transpose Lines 1,2,3 For 1,2 or 3 Neighbors 28 Frames.gif', writer='pillow', fps=14)

plt.show()
